generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// manages app users
model User {
  id            String         @id @default(cuid())
  clerk_id      String         @unique
  name          String
  conversations Conversation[]
  created_at    DateTime       @default(now())
  updated_at    DateTime       @updatedAt
  Speaker       Speaker[]
}

// manages recording metadata
model Conversation {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user_id       String
  user          User     @relation(fields: [user_id], references: [clerk_id])
  title         String
  recording_url String // Storage location of the recording file (e.g. S3 bucket)
  duration      Int // Duration of the recording in seconds
  transcript    Json // Raw transcript JSON from service
  summary       String // AI-generated summary of the conversation

  // Relations to analyzed elements
  segments     Segment[]
  themes       Theme[]
  participants ConversationParticipant[]
}

// manages known speakers
model Speaker {
  id          String                    @id @default(cuid())
  created_at  DateTime                  @default(now())
  updated_at  DateTime                  @updatedAt
  name        String // The canonical name for this speaker
  user_id     String? // Optional link if the speaker is a registered user
  user        User?                     @relation(fields: [user_id], references: [id])
  appearances ConversationParticipant[]
}

// Segments are meaningful chunks of the conversation that can be analyzed for themes, emotions, etc.
model Segment {
  id              String                  @id @default(cuid())
  conversation_id String
  conversation    Conversation            @relation(fields: [conversation_id], references: [id])
  participant_id  String // the Segment model should maintain its own reference to which participant was speaking
  participant     ConversationParticipant @relation(fields: [participant_id], references: [id])
  start_time      Float // Time in seconds
  end_time        Float
  text            String // The actual segment content
  themes          SegmentTheme[]
}

// The high-level topics or themes that emerge from the conversation
model Theme {
  id              String         @id @default(cuid())
  name            String
  conversation_id String
  conversation    Conversation   @relation(fields: [conversation_id], references: [id])
  segments        SegmentTheme[]
  //confidence      Float?    // How confident we are in this theme assignment
}

// This is a many-to-many relationship between segments and themes
// a list of connections between segments and themes
model SegmentTheme {
  segment_id String
  segment    Segment @relation(fields: [segment_id], references: [id])
  theme_id   String
  theme      Theme   @relation(fields: [theme_id], references: [id])

  @@id([segment_id, theme_id]) //Use the combination of segment_id and theme_id as the unique identifier for each row
}

// manages participants in a conversation and when they appear
model ConversationParticipant {
  id              String       @id @default(cuid())
  conversation_id String
  conversation    Conversation @relation(fields: [conversation_id], references: [id])

  // speaker identification
  // This can start as null and be filled in when the user identifies the speaker
  speaker_id      String?
  speaker         Speaker? @relation(fields: [speaker_id], references: [id])
  // The temporary label used before speaker identification (e.g., "Speaker 1")
  temporary_label String

  // The segments where this participant speaks
  segments Segment[]
}

// the schema should support queries like this:

// Find all segments for a theme in a conversation
// const themeSegments = await prisma.theme.findUnique({
//   where: { id: themeId },
//   include: {
//     segments: {
//       include: {
//         segment: true
//       }
//     }
//   }
// });

// Find all themes discussed by a specific speaker
// const speakerThemes = await prisma.segment.findMany({
//   where: { speaker: speakerId },
//   include: {
//     themes: {
//       include: {
//         theme: true
//       }
//     }
//   }
// });
